# Web Workers 學習紀錄

## 檔案說明
* multiply.html - 官方範例：兩數相乘html檔
* single-thread.html - 以原始方式在js中直接讀出檔案並畫在網頁上
* multi-workers.html - 以開多個workers的方讀出檔案並畫在網頁上
* sub-workers.html - 以子workers的方式把讀檔案的工作完全切出去
* ./js/multiply.js - 官方範例 :兩數相乘js檔
* ./js/readfile.js - 以fileReader的方式讀出一個檔案
* ./js/readfile2.js - 根據傳入的檔案數開啟多個子workers去讀出檔案
* ./js/timeChart.js - 繪製多執行緒的時間圖，需在程式中加入時間資料

### 傳值方式
* 雙方都以postMessage(data)來傳遞資料
* 雙方都以onmessage事件來接收資料

### 使用注意事項
* 不能在worker中執行dom的操作
* 內部關閉使用close()
* 外部關閉使用terminate()

### 效能比較
* 寫一段程式以FileReader()的方式來同時讀取12個MP3檔案
* 以readAsDataURL()的方式將MP3轉成base64的格式再塞回auodio的src
* 第一種方式是直接以原生js的方式在主執行緒進行批次讀檔的動作
* 第二種方式是把主執行緒的批次讀檔動作改成讓workder去執行
* 第三種方式是把迴圈開worker的動作交給另一個worker去執行
* 比較單執行緒和多執行緒的差異
* 單執行緒跑十次的結果(亳秒)：
  * [1540, 1594, 1644, 1705, 1664, 1655, 1675, 1705, 1720, 1700]
  * 平均1659.8亳秒，每次的執行時間也很平均
* 多執行緒跑十次的結果(亳秒)：
  * 主執行緒[706, 645, 949, 984, 1062, 876, 892, 795, 771, 904]
  * 次執行緒[51, 16, 32, 18, 17, 42, 38, 28, 38, 51]
  * 主執行緒平均858.4亳秒，次執行緒平均33.1亳秒，每次的執行時間不穩定，但最慢的也還是比單執行緒快
* 把多執行緒的工作切出去給worker管理的做法，跑十次的結果(亳秒)：
  * 主執行緒[227, 239, 255, 247, 205, 233, 217, 254, 236, 244]
  * 次執行緒[140, 170, 214, 181, 203, 242, 20Aa0, 138, 189, 203]
  * 主執行緒平均235.7亳秒，次執行緒平均188亳秒，每次的執行時間變得穩定，整體執行時間更快。
* 小結:Workers的確可以提高js的執行效能，尤其是在非同步及大量運算的工作上，但worker的設計方式也會影響到實際的效能，採用對的策略來善用worker才是有意義的。

### 改善方案
* readAsDataURL()解出來的內容都幾十mb，因此在傳輸和最後寫入tag時都太耗時
* 改成readAsArrayBuffer()，同時將檔案轉成blob。
* 最後將blob再以URL.createObjectURL()的方式產生src塞入tag，以參照的方式來節省傳輸的資料及src的長度
* 改完後再測試三種做法的效率：
  * 單執行緒跑十次的結果是平均312亳秒
  * 多執行緒跑十次的結果是平均299亳秒
  * 次執行緒跑十次的結果是平均295亳秒
* 小結:Workers的確可以提高js的執行效能，但如果運算不是太複雜的話，效益不大，使用上需評估邊際效益，不然就有點殺雞用牛刀的感覺